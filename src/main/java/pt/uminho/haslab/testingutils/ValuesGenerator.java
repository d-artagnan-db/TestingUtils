package pt.uminho.haslab.testingutils;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.*;

public class ValuesGenerator {
	private final static SecureRandom generator = new SecureRandom();

	/*
	 * The values generated by these testes must be between 0 and 62. The
	 * reasons for this are that the sharemind dealer allways uses a mod of
	 * nbits +1.If the generated value is 62 then the mod will be 63. Since the
	 * values are being exchnaged by a protocol buffer message that is assuming
	 * longs, and the secrets are converted to longs, then the maximum value of
	 * a long is (2^63) -1. Long uses 64 bits, one for sign and the other 63 to
	 * hold the value.
	 */
	public static final int maxBits = 62;

	public static final int nValues = 95;

	public static final int batchValues = 200;

	/* Number of bits must be greater than 0 */
	private static int genNumberBits(int maxBits) {
		int nBits = generator.nextInt(maxBits);
		if (nBits == 0) {
			return 1;
		}
		return nBits;

	}

	public static Collection SingleValueGenerator() {
		Object[] parameters = new Object[nValues];

		for (int i = 0; i < nValues; i++) {

			int genNbits = genNumberBits(maxBits);
			BigInteger genValue = new BigInteger(genNbits, generator);

			Object[] parameter = new Object[2];
			parameter[0] = genNbits;
			parameter[1] = genValue;
			parameters[i] = parameter;
		}

		return Arrays.asList(parameters);
	}

	public static List<BigInteger> microbenchMarkValueGenerator(int nVals) {
		List<BigInteger> values = new ArrayList<BigInteger>();

		for (int i = 0; i < nVals; i++) {

			int genNbits = genNumberBits(maxBits);
			BigInteger genValue = new BigInteger(genNbits, generator);
			values.add(genValue);
		}

		return values;
	}

	public static String randomString(int nbits) {
		char[] chars = "abcdefghijklmnopqrstuvwxyz".toCharArray();
		StringBuilder sb = new StringBuilder();
		Random random = new Random();
		for (int i = 0; i < nbits; i++) {
			char c = chars[random.nextInt(chars.length)];
			sb.append(c);
		}
		return sb.toString();
	}

	public static String randomNumber(int nbits) {
		char[] chars = "0123456789".toCharArray();
		StringBuilder sb = new StringBuilder();
		Random random = new Random();
		for (int i = 0; i < nbits; i++) {
			char c = chars[random.nextInt(chars.length)];
			sb.append(c);
		}
		return sb.toString();
	}

	public static Collection TestPeerGenerator() {

		Object[] parameters = new Object[2];
		for (int i = 0; i < 2; i++) {
			List<byte[]> peerOne = new ArrayList<byte[]>();
			List<byte[]> peerTwo = new ArrayList<byte[]>();
			List<byte[]> peerThree = new ArrayList<byte[]>();

			int nBits = generator.nextInt(ValuesGenerator.maxBits);

			if (nBits == 0) {
				nBits++;
			}

			for (int j = 0; j < nValues; j++) {
				peerOne.add(randomString(nBits).getBytes());
				peerTwo.add(randomString(nBits).getBytes());
				peerThree.add(randomString(nBits).getBytes());
			}

			Object[] parameter = new Object[4];
			parameter[0] = peerOne;
			parameter[1] = peerTwo;
			parameter[2] = peerThree;
			parameter[3] = i;// Test rotate Left (0) and rotate right(1)
			parameters[i] = parameter;

		}

		return Arrays.asList(parameters);

	}

	public static Collection SendAndReceiveMessageBrokerTest() {
		Object[] parameters = new Object[nValues];

		for (int i = 0; i < nValues; i++) {

			int nMessages = generator.nextInt(ValuesGenerator.maxBits);
			int genNbits = genNumberBits(maxBits);

			List<BigInteger> peerOne = new ArrayList<BigInteger>();
			List<BigInteger> peerTwo = new ArrayList<BigInteger>();
			List<BigInteger> peerThree = new ArrayList<BigInteger>();

			if (nMessages == 0) {
				nMessages++;
			}

			for (int k = 0; k < nMessages; k++) {
				BigInteger valOne = new BigInteger(genNbits, generator);
				BigInteger valTwo = new BigInteger(genNbits, generator);
				BigInteger valThree = new BigInteger(genNbits, generator);
				peerOne.add(valOne);
				peerTwo.add(valTwo);
				peerThree.add(valThree);
			}

			Object[] parameter = new Object[3];
			parameter[0] = peerOne;
			parameter[1] = peerTwo;
			parameter[2] = peerThree;
			parameters[i] = parameter;

		}

		return Arrays.asList(parameters);
	}

	public static Collection SendAndReceiveMessageBrokerTest2() {
		Object[] parameters = new Object[1];

		List<BigInteger> peerOne = new ArrayList<BigInteger>();
		List<BigInteger> peerTwo = new ArrayList<BigInteger>();
		List<BigInteger> peerThree = new ArrayList<BigInteger>();

		for (int i = 0; i < nValues; i++) {

			int genNbits = genNumberBits(maxBits);

			BigInteger valOne = new BigInteger(genNbits, generator);
			BigInteger valTwo = new BigInteger(genNbits, generator);
			BigInteger valThree = new BigInteger(genNbits, generator);
			peerOne.add(valOne);
			peerTwo.add(valTwo);
			peerThree.add(valThree);

		}
		Object[] parameter = new Object[3];
		parameter[0] = peerOne;
		parameter[1] = peerTwo;
		parameter[2] = peerThree;
		parameters[0] = parameter;

		return Arrays.asList(parameters);
	}

	public static Collection SendAndReceiveBatchMessageBrokerTest2() {
		Object[] parameters = new Object[1];

		List<List<BigInteger>> peerOne = new ArrayList<List<BigInteger>>();
		List<List<BigInteger>> peerTwo = new ArrayList<List<BigInteger>>();
		List<List<BigInteger>> peerThree = new ArrayList<List<BigInteger>>();

		for (int i = 0; i < nValues; i++) {

			int genNbits = genNumberBits(maxBits);
			List<BigInteger> valsOne = new ArrayList<BigInteger>();
			List<BigInteger> valsTwo = new ArrayList<BigInteger>();
			List<BigInteger> valsThree = new ArrayList<BigInteger>();

			for (int j = 0; j < batchValues; j++) {
				BigInteger valOne = new BigInteger(genNbits, generator);
				BigInteger valTwo = new BigInteger(genNbits, generator);
				BigInteger valThree = new BigInteger(genNbits, generator);

				valsOne.add(valOne);
				valsTwo.add(valTwo);
				valsThree.add(valThree);
			}
			peerOne.add(valsOne);
			peerTwo.add(valsTwo);
			peerThree.add(valsThree);

		}
		Object[] parameter = new Object[3];
		parameter[0] = peerOne;
		parameter[1] = peerTwo;
		parameter[2] = peerThree;
		parameters[0] = parameter;

		return Arrays.asList(parameters);
	}

	public static List<BigInteger> BootPlayerList() {

		List<BigInteger> values = new ArrayList<BigInteger>();

		for (int i = 0; i < nValues; i++) {
			/**
			 * The values being generated are between 0 and (2^63)-1. At most
			 * there will be 63 bits. The secrets will have 64 bits, but the
			 * parameter must be 63.
			 */

			values.add(new BigInteger(maxBits, generator));

		}

		return values;
	}

	public static List<BigInteger> equalSearchEndpointList() {

		List<BigInteger> values = new ArrayList<BigInteger>();

		// Ensures that every value is different
		for (int i = 0; i < nValues; i++) {
			BigInteger newValue = new BigInteger(maxBits, generator);
			if (values.contains(newValue)) {
				i--;
			} else {
				values.add(newValue);
			}
		}
		return values;
	}

	public static List<BigInteger> fixedEqualSearchEndpointList() {
		List<BigInteger> values = new ArrayList<BigInteger>();

		values.add(BigInteger.valueOf(200));
		// values.add(BigInteger.valueOf(300));
		// values.add(BigInteger.valueOf(400));
		// values.add(BigInteger.valueOf(500));
		values.add(BigInteger.valueOf(600));
		values.add(BigInteger.valueOf(700));
		// values.add(BigInteger.valueOf(800));
		// values.add(BigInteger.valueOf(900));
		values.add(BigInteger.valueOf(950));

		return values;

	}

	public static Collection TwoValuesGenerator() {
		Object[] parameters = new Object[1];
		List<Integer> nBits = new ArrayList<Integer>();
		List<BigInteger> firstValues = new ArrayList<BigInteger>();
		List<BigInteger> secondValues = new ArrayList<BigInteger>();

		for (int i = 0; i < nValues; i++) {

			int genNbits = maxBits;// genNumberBits(maxBits);
			BigInteger genValueOne = new BigInteger(genNbits, generator);
			BigInteger genValueTwo = new BigInteger(genNbits, generator);

			nBits.add(genNbits);
			firstValues.add(genValueOne);
			secondValues.add(genValueTwo);

		}

		Object[] parameter = new Object[3];
		parameter[0] = nBits;
		parameter[1] = firstValues;
		parameter[2] = secondValues;

		parameters[0] = parameter;
		return Arrays.asList(parameters);
	}

	public static Collection TwoBatchValuesGenerator() {
		Object[] parameters = new Object[1];
		List<Integer> nBits = new ArrayList<Integer>();
		List<List<BigInteger>> firstValues = new ArrayList<List<BigInteger>>();
		List<List<BigInteger>> secondValues = new ArrayList<List<BigInteger>>();

		for (int i = 0; i < nValues; i++) {

			int genNbits = genNumberBits(maxBits);
			List<BigInteger> genValsOne = new ArrayList<BigInteger>();
			List<BigInteger> genValsTwo = new ArrayList<BigInteger>();

			for (int j = 0; j < batchValues; j++) {
				BigInteger genValueOne = new BigInteger(genNbits, generator);
				BigInteger genValueTwo = new BigInteger(genNbits, generator);
				genValsOne.add(genValueOne);
				genValsTwo.add(genValueTwo);

			}

			nBits.add(genNbits);
			firstValues.add(genValsOne);
			secondValues.add(genValsTwo);

		}

		Object[] parameter = new Object[3];
		parameter[0] = nBits;
		parameter[1] = firstValues;
		parameter[2] = secondValues;

		parameters[0] = parameter;
		return Arrays.asList(parameters);
	}

	public static Collection ShareConvGenerator() {
		Object[] parameters = new Object[1];
		List<Integer> nBits = new ArrayList<Integer>();
		List<BigInteger> valuesOne = new ArrayList<BigInteger>();
		List<BigInteger> valuesTwo = new ArrayList<BigInteger>();
		List<BigInteger> valuesThree = new ArrayList<BigInteger>();

		for (int i = 0; i < nValues; i++) {
			int genNbits = genNumberBits(maxBits);

			BigInteger genValueOne = new BigInteger(1, generator);
			BigInteger genValueTwo = new BigInteger(1, generator);
			BigInteger genValueThree = new BigInteger(1, generator);
			nBits.add(genNbits);
			valuesOne.add(genValueOne);
			valuesTwo.add(genValueTwo);
			valuesThree.add(genValueThree);
		}
		Object[] parameter = new Object[4];
		parameter[0] = nBits;
		parameter[1] = valuesOne;
		parameter[2] = valuesTwo;
		parameter[3] = valuesThree;

		parameters[0] = parameter;
		return Arrays.asList(parameters);
	}

	public static Collection SingleListValuesGenerator() {
		Object[] parameters = new Object[1];

		List<BigInteger> values = new ArrayList<BigInteger>();

		// Ensures that every value is different
		for (int i = 0; i < nValues; i++) {
			BigInteger newValue = new BigInteger(maxBits, generator);
			if (values.contains(newValue)) {
				i--;
			} else {
				values.add(newValue);
			}
		}

		Object[] parameter = new Object[2];
		parameter[0] = maxBits;
		parameter[1] = values;
		parameters[0] = parameter;

		return Arrays.asList(parameters);
	}

	public static Collection protocolResultsGenerator() {
		Object[] parameters = new Object[1];

		List<Integer> ids = new ArrayList<Integer>();
		int Low = 0;
		int High = 3;

		for (int i = 0; i < nValues; i++) {
			// generates a random target player id
			int target = generator.nextInt(High - Low) + Low;
			ids.add(target);
		}

		Object[] parameter = new Object[3];
		parameter[0] = ids;
		// Number of messages players have to send
		parameter[1] = genNumberBits(maxBits);
		// Number of bits of the values each player will generate
		parameter[2] = genNumberBits(maxBits);
		parameters[0] = parameter;

		return Arrays.asList(parameters);

	}

	public static Collection FilterIndexesGenerator() {
		Object[] parameters = new Object[1];

		List<Integer> ids = new ArrayList<Integer>();
		List<BigInteger> indexes = new ArrayList<BigInteger>();

		int Low = 0;
		int High = 3;

		for (int i = 0; i < nValues; i++) {
			// generates a random target player id
			int target = generator.nextInt(High - Low) + Low;
			ids.add(target);
			indexes.add(new BigInteger(maxBits, generator));
		}

		Object[] parameter = new Object[2];
		parameter[0] = ids;
		parameter[1] = indexes;
		parameters[0] = parameter;

		return Arrays.asList(parameters);
	}

	public static Collection concurrentPutGetGenerator(int nVals, int nThreads) {
		Object[] parameters = new Object[1];

		List<BigInteger> vals = new ArrayList<BigInteger>();
		List<List<BigInteger>> identifiers = new ArrayList<List<BigInteger>>();
		List<BigInteger> playerIdent = new ArrayList<BigInteger>();

		for (int i = 0; i < nVals * nThreads; i++) {

			BigInteger val = new BigInteger(maxBits, generator);
			BigInteger identifier = BigInteger.valueOf(i);
			vals.add(val);
			playerIdent.add(identifier);
			if ((i + 1) % nVals == 0) {
				identifiers.add(playerIdent);
				playerIdent = new ArrayList<BigInteger>();
			}
		}

		Object[] parameter = new Object[2];
		parameter[0] = vals;
		parameter[1] = identifiers;
		parameters[0] = parameter;

		return Arrays.asList(parameters);
	}

	public static Collection ClientCacheGenerator(int nVals, int nThreads,
			int nTables) {
		Object[] parameters = new Object[1];
		List<List<Long>> values = new ArrayList<List<Long>>();
		List<String> tables = new ArrayList<String>();

		for (int i = 0; i < nThreads; i++) {
			List<Long> vals = new ArrayList<Long>();

			for (int j = 0; j < nVals; j++) {
				vals.add(generator.nextLong());
			}
			values.add(vals);
		}

		for (int i = 0; i < nTables; i++) {
			tables.add(randomString(5));
		}
		Object[] parameter = new Object[2];
		parameter[0] = values;
		parameter[1] = tables;
		parameters[0] = parameter;

		return Arrays.asList(parameters);

	}

	public static Collection RedisTestValueGenerator() {
		Object[] parameters = new Object[1];
		List<String> ips = new ArrayList<String>();
		List<Integer> ports = new ArrayList<Integer>();
		String ip = "192.168.12.";

		BigInteger requestID = new BigInteger(maxBits, generator);
		BigInteger regionID = new BigInteger(maxBits, generator);

		for (int i = 0; i < 3; i++) {
			int ipsufix = generator.nextInt();
			int port = generator.nextInt();
			String destip = ip + ipsufix;

			ips.add(destip);
			ports.add(port);
		}

		Object[] parameter = new Object[4];
		parameter[0] = requestID;
		parameter[1] = regionID;
		parameter[2] = ips;
		parameter[3] = ports;
		parameters[0] = parameter;

		return Arrays.asList(parameters);

	}

}
